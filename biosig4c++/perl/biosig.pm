# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.40
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package biosig;
use base qw(Exporter);
use base qw(DynaLoader);
package biosigc;
bootstrap biosig;
package biosig;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package biosig;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package biosig;

*imaxabs = *biosigc::imaxabs;
*imaxdiv = *biosigc::imaxdiv;
*strtoimax = *biosigc::strtoimax;
*strtoumax = *biosigc::strtoumax;
*constructHDR = *biosigc::constructHDR;
*destructHDR = *biosigc::destructHDR;
*sopen = *biosigc::sopen;
*sclose = *biosigc::sclose;
*sread = *biosigc::sread;
*swrite = *biosigc::swrite;
*seof = *biosigc::seof;
*srewind = *biosigc::srewind;
*sseek = *biosigc::sseek;
*stell = *biosigc::stell;
*RerefCHANNEL = *biosigc::RerefCHANNEL;
*GetFileTypeString = *biosigc::GetFileTypeString;
*sload = *biosigc::sload;
*PhysDimCode = *biosigc::PhysDimCode;
*PhysDim = *biosigc::PhysDim;
*sort_eventtable = *biosigc::sort_eventtable;
*convert2to4_eventtable = *biosigc::convert2to4_eventtable;
*convert4to2_eventtable = *biosigc::convert4to2_eventtable;
*hdr2ascii = *biosigc::hdr2ascii;

############# Class : biosig::imaxdiv_t ##############

package biosig::imaxdiv_t;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_quot_get = *biosigc::imaxdiv_t_quot_get;
*swig_quot_set = *biosigc::imaxdiv_t_quot_set;
*swig_rem_get = *biosigc::imaxdiv_t_rem_get;
*swig_rem_set = *biosigc::imaxdiv_t_rem_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_imaxdiv_t(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_imaxdiv_t($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::CHANNEL_TYPE ##############

package biosig::CHANNEL_TYPE;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_PhysMin_get = *biosigc::CHANNEL_TYPE_PhysMin_get;
*swig_PhysMin_set = *biosigc::CHANNEL_TYPE_PhysMin_set;
*swig_PhysMax_get = *biosigc::CHANNEL_TYPE_PhysMax_get;
*swig_PhysMax_set = *biosigc::CHANNEL_TYPE_PhysMax_set;
*swig_DigMin_get = *biosigc::CHANNEL_TYPE_DigMin_get;
*swig_DigMin_set = *biosigc::CHANNEL_TYPE_DigMin_set;
*swig_DigMax_get = *biosigc::CHANNEL_TYPE_DigMax_get;
*swig_DigMax_set = *biosigc::CHANNEL_TYPE_DigMax_set;
*swig_Cal_get = *biosigc::CHANNEL_TYPE_Cal_get;
*swig_Cal_set = *biosigc::CHANNEL_TYPE_Cal_set;
*swig_Off_get = *biosigc::CHANNEL_TYPE_Off_get;
*swig_Off_set = *biosigc::CHANNEL_TYPE_Off_set;
*swig_OnOff_get = *biosigc::CHANNEL_TYPE_OnOff_get;
*swig_OnOff_set = *biosigc::CHANNEL_TYPE_OnOff_set;
*swig_Label_get = *biosigc::CHANNEL_TYPE_Label_get;
*swig_Label_set = *biosigc::CHANNEL_TYPE_Label_set;
*swig_LeadIdCode_get = *biosigc::CHANNEL_TYPE_LeadIdCode_get;
*swig_LeadIdCode_set = *biosigc::CHANNEL_TYPE_LeadIdCode_set;
*swig_Transducer_get = *biosigc::CHANNEL_TYPE_Transducer_get;
*swig_Transducer_set = *biosigc::CHANNEL_TYPE_Transducer_set;
*swig_PhysDimCode_get = *biosigc::CHANNEL_TYPE_PhysDimCode_get;
*swig_PhysDimCode_set = *biosigc::CHANNEL_TYPE_PhysDimCode_set;
*swig_LowPass_get = *biosigc::CHANNEL_TYPE_LowPass_get;
*swig_LowPass_set = *biosigc::CHANNEL_TYPE_LowPass_set;
*swig_HighPass_get = *biosigc::CHANNEL_TYPE_HighPass_get;
*swig_HighPass_set = *biosigc::CHANNEL_TYPE_HighPass_set;
*swig_Notch_get = *biosigc::CHANNEL_TYPE_Notch_get;
*swig_Notch_set = *biosigc::CHANNEL_TYPE_Notch_set;
*swig_XYZ_get = *biosigc::CHANNEL_TYPE_XYZ_get;
*swig_XYZ_set = *biosigc::CHANNEL_TYPE_XYZ_set;
*swig_Impedance_get = *biosigc::CHANNEL_TYPE_Impedance_get;
*swig_Impedance_set = *biosigc::CHANNEL_TYPE_Impedance_set;
*swig_fZ_get = *biosigc::CHANNEL_TYPE_fZ_get;
*swig_fZ_set = *biosigc::CHANNEL_TYPE_fZ_set;
*swig_GDFTYP_get = *biosigc::CHANNEL_TYPE_GDFTYP_get;
*swig_GDFTYP_set = *biosigc::CHANNEL_TYPE_GDFTYP_set;
*swig_SPR_get = *biosigc::CHANNEL_TYPE_SPR_get;
*swig_SPR_set = *biosigc::CHANNEL_TYPE_SPR_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_CHANNEL_TYPE(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_CHANNEL_TYPE($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE ##############

package biosig::HDRTYPE;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_TYPE_get = *biosigc::HDRTYPE_TYPE_get;
*swig_TYPE_set = *biosigc::HDRTYPE_TYPE_set;
*swig_VERSION_get = *biosigc::HDRTYPE_VERSION_get;
*swig_VERSION_set = *biosigc::HDRTYPE_VERSION_set;
*swig_FileName_get = *biosigc::HDRTYPE_FileName_get;
*swig_FileName_set = *biosigc::HDRTYPE_FileName_set;
*swig_HeadLen_get = *biosigc::HDRTYPE_HeadLen_get;
*swig_HeadLen_set = *biosigc::HDRTYPE_HeadLen_set;
*swig_NS_get = *biosigc::HDRTYPE_NS_get;
*swig_NS_set = *biosigc::HDRTYPE_NS_set;
*swig_SPR_get = *biosigc::HDRTYPE_SPR_get;
*swig_SPR_set = *biosigc::HDRTYPE_SPR_set;
*swig_NRec_get = *biosigc::HDRTYPE_NRec_get;
*swig_NRec_set = *biosigc::HDRTYPE_NRec_set;
*swig_SampleRate_get = *biosigc::HDRTYPE_SampleRate_get;
*swig_SampleRate_set = *biosigc::HDRTYPE_SampleRate_set;
*swig_IPaddr_get = *biosigc::HDRTYPE_IPaddr_get;
*swig_IPaddr_set = *biosigc::HDRTYPE_IPaddr_set;
*swig_LOC_get = *biosigc::HDRTYPE_LOC_get;
*swig_LOC_set = *biosigc::HDRTYPE_LOC_set;
*swig_T0_get = *biosigc::HDRTYPE_T0_get;
*swig_T0_set = *biosigc::HDRTYPE_T0_set;
*swig_tzmin_get = *biosigc::HDRTYPE_tzmin_get;
*swig_tzmin_set = *biosigc::HDRTYPE_tzmin_set;
*swig_CHANNEL_get = *biosigc::HDRTYPE_CHANNEL_get;
*swig_CHANNEL_set = *biosigc::HDRTYPE_CHANNEL_set;
*swig_aECG_get = *biosigc::HDRTYPE_aECG_get;
*swig_aECG_set = *biosigc::HDRTYPE_aECG_set;
*swig_AS_get = *biosigc::HDRTYPE_AS_get;
*swig_AS_set = *biosigc::HDRTYPE_AS_set;
*swig_FILE_get = *biosigc::HDRTYPE_FILE_get;
*swig_FILE_set = *biosigc::HDRTYPE_FILE_set;
*swig_FLAG_get = *biosigc::HDRTYPE_FLAG_get;
*swig_FLAG_set = *biosigc::HDRTYPE_FLAG_set;
*swig_EVENT_get = *biosigc::HDRTYPE_EVENT_get;
*swig_EVENT_set = *biosigc::HDRTYPE_EVENT_set;
*swig_ELEC_get = *biosigc::HDRTYPE_ELEC_get;
*swig_ELEC_set = *biosigc::HDRTYPE_ELEC_set;
*swig_ID_get = *biosigc::HDRTYPE_ID_get;
*swig_ID_set = *biosigc::HDRTYPE_ID_set;
*swig_Patient_get = *biosigc::HDRTYPE_Patient_get;
*swig_Patient_set = *biosigc::HDRTYPE_Patient_set;
*swig_data_get = *biosigc::HDRTYPE_data_get;
*swig_data_set = *biosigc::HDRTYPE_data_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_AS ##############

package biosig::HDRTYPE_AS;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_bpb_get = *biosigc::HDRTYPE_AS_bpb_get;
*swig_bpb_set = *biosigc::HDRTYPE_AS_bpb_set;
*swig_bpb8_get = *biosigc::HDRTYPE_AS_bpb8_get;
*swig_bpb8_set = *biosigc::HDRTYPE_AS_bpb8_set;
*swig_Header_get = *biosigc::HDRTYPE_AS_Header_get;
*swig_Header_set = *biosigc::HDRTYPE_AS_Header_set;
*swig_rawEventData_get = *biosigc::HDRTYPE_AS_rawEventData_get;
*swig_rawEventData_set = *biosigc::HDRTYPE_AS_rawEventData_set;
*swig_rawdata_get = *biosigc::HDRTYPE_AS_rawdata_get;
*swig_rawdata_set = *biosigc::HDRTYPE_AS_rawdata_set;
*swig_flag_collapsed_rawdata_get = *biosigc::HDRTYPE_AS_flag_collapsed_rawdata_get;
*swig_flag_collapsed_rawdata_set = *biosigc::HDRTYPE_AS_flag_collapsed_rawdata_set;
*swig_first_get = *biosigc::HDRTYPE_AS_first_get;
*swig_first_set = *biosigc::HDRTYPE_AS_first_set;
*swig_length_get = *biosigc::HDRTYPE_AS_length_get;
*swig_length_set = *biosigc::HDRTYPE_AS_length_set;
*swig_auxBUF_get = *biosigc::HDRTYPE_AS_auxBUF_get;
*swig_auxBUF_set = *biosigc::HDRTYPE_AS_auxBUF_set;
*swig_bci2000_get = *biosigc::HDRTYPE_AS_bci2000_get;
*swig_bci2000_set = *biosigc::HDRTYPE_AS_bci2000_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_AS(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_AS($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_FILE ##############

package biosig::HDRTYPE_FILE;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_FID_get = *biosigc::HDRTYPE_FILE_FID_get;
*swig_FID_set = *biosigc::HDRTYPE_FILE_FID_set;
*swig_POS_get = *biosigc::HDRTYPE_FILE_POS_get;
*swig_POS_set = *biosigc::HDRTYPE_FILE_POS_set;
*swig_OPEN_get = *biosigc::HDRTYPE_FILE_OPEN_get;
*swig_OPEN_set = *biosigc::HDRTYPE_FILE_OPEN_set;
*swig_LittleEndian_get = *biosigc::HDRTYPE_FILE_LittleEndian_get;
*swig_LittleEndian_set = *biosigc::HDRTYPE_FILE_LittleEndian_set;
*swig_COMPRESSION_get = *biosigc::HDRTYPE_FILE_COMPRESSION_get;
*swig_COMPRESSION_set = *biosigc::HDRTYPE_FILE_COMPRESSION_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_FILE(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_FILE($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_FLAG ##############

package biosig::HDRTYPE_FLAG;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_OVERFLOWDETECTION_get = *biosigc::HDRTYPE_FLAG_OVERFLOWDETECTION_get;
*swig_OVERFLOWDETECTION_set = *biosigc::HDRTYPE_FLAG_OVERFLOWDETECTION_set;
*swig_UCAL_get = *biosigc::HDRTYPE_FLAG_UCAL_get;
*swig_UCAL_set = *biosigc::HDRTYPE_FLAG_UCAL_set;
*swig_ANONYMOUS_get = *biosigc::HDRTYPE_FLAG_ANONYMOUS_get;
*swig_ANONYMOUS_set = *biosigc::HDRTYPE_FLAG_ANONYMOUS_set;
*swig_ROW_BASED_CHANNELS_get = *biosigc::HDRTYPE_FLAG_ROW_BASED_CHANNELS_get;
*swig_ROW_BASED_CHANNELS_set = *biosigc::HDRTYPE_FLAG_ROW_BASED_CHANNELS_set;
*swig_TARGETSEGMENT_get = *biosigc::HDRTYPE_FLAG_TARGETSEGMENT_get;
*swig_TARGETSEGMENT_set = *biosigc::HDRTYPE_FLAG_TARGETSEGMENT_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_FLAG(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_FLAG($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_EVENT ##############

package biosig::HDRTYPE_EVENT;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_SampleRate_get = *biosigc::HDRTYPE_EVENT_SampleRate_get;
*swig_SampleRate_set = *biosigc::HDRTYPE_EVENT_SampleRate_set;
*swig_N_get = *biosigc::HDRTYPE_EVENT_N_get;
*swig_N_set = *biosigc::HDRTYPE_EVENT_N_set;
*swig_TYP_get = *biosigc::HDRTYPE_EVENT_TYP_get;
*swig_TYP_set = *biosigc::HDRTYPE_EVENT_TYP_set;
*swig_POS_get = *biosigc::HDRTYPE_EVENT_POS_get;
*swig_POS_set = *biosigc::HDRTYPE_EVENT_POS_set;
*swig_DUR_get = *biosigc::HDRTYPE_EVENT_DUR_get;
*swig_DUR_set = *biosigc::HDRTYPE_EVENT_DUR_set;
*swig_CHN_get = *biosigc::HDRTYPE_EVENT_CHN_get;
*swig_CHN_set = *biosigc::HDRTYPE_EVENT_CHN_set;
*swig_CodeDesc_get = *biosigc::HDRTYPE_EVENT_CodeDesc_get;
*swig_CodeDesc_set = *biosigc::HDRTYPE_EVENT_CodeDesc_set;
*swig_LenCodeDesc_get = *biosigc::HDRTYPE_EVENT_LenCodeDesc_get;
*swig_LenCodeDesc_set = *biosigc::HDRTYPE_EVENT_LenCodeDesc_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_EVENT(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_EVENT($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_ELEC ##############

package biosig::HDRTYPE_ELEC;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_REF_get = *biosigc::HDRTYPE_ELEC_REF_get;
*swig_REF_set = *biosigc::HDRTYPE_ELEC_REF_set;
*swig_GND_get = *biosigc::HDRTYPE_ELEC_GND_get;
*swig_GND_set = *biosigc::HDRTYPE_ELEC_GND_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_ELEC(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_ELEC($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_ID ##############

package biosig::HDRTYPE_ID;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_Recording_get = *biosigc::HDRTYPE_ID_Recording_get;
*swig_Recording_set = *biosigc::HDRTYPE_ID_Recording_set;
*swig_Technician_get = *biosigc::HDRTYPE_ID_Technician_get;
*swig_Technician_set = *biosigc::HDRTYPE_ID_Technician_set;
*swig_Hospital_get = *biosigc::HDRTYPE_ID_Hospital_get;
*swig_Hospital_set = *biosigc::HDRTYPE_ID_Hospital_set;
*swig_Equipment_get = *biosigc::HDRTYPE_ID_Equipment_get;
*swig_Equipment_set = *biosigc::HDRTYPE_ID_Equipment_set;
*swig_Manufacturer_get = *biosigc::HDRTYPE_ID_Manufacturer_get;
*swig_Manufacturer_set = *biosigc::HDRTYPE_ID_Manufacturer_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_ID(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_ID($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_ID_Manufacturer ##############

package biosig::HDRTYPE_ID_Manufacturer;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_Name_get = *biosigc::HDRTYPE_ID_Manufacturer_Name_get;
*swig_Name_set = *biosigc::HDRTYPE_ID_Manufacturer_Name_set;
*swig_Model_get = *biosigc::HDRTYPE_ID_Manufacturer_Model_get;
*swig_Model_set = *biosigc::HDRTYPE_ID_Manufacturer_Model_set;
*swig_Version_get = *biosigc::HDRTYPE_ID_Manufacturer_Version_get;
*swig_Version_set = *biosigc::HDRTYPE_ID_Manufacturer_Version_set;
*swig_SerialNumber_get = *biosigc::HDRTYPE_ID_Manufacturer_SerialNumber_get;
*swig_SerialNumber_set = *biosigc::HDRTYPE_ID_Manufacturer_SerialNumber_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_ID_Manufacturer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_ID_Manufacturer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_Patient ##############

package biosig::HDRTYPE_Patient;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_Name_get = *biosigc::HDRTYPE_Patient_Name_get;
*swig_Name_set = *biosigc::HDRTYPE_Patient_Name_set;
*swig_Id_get = *biosigc::HDRTYPE_Patient_Id_get;
*swig_Id_set = *biosigc::HDRTYPE_Patient_Id_set;
*swig_Weight_get = *biosigc::HDRTYPE_Patient_Weight_get;
*swig_Weight_set = *biosigc::HDRTYPE_Patient_Weight_set;
*swig_Height_get = *biosigc::HDRTYPE_Patient_Height_get;
*swig_Height_set = *biosigc::HDRTYPE_Patient_Height_set;
*swig_Birthday_get = *biosigc::HDRTYPE_Patient_Birthday_get;
*swig_Birthday_set = *biosigc::HDRTYPE_Patient_Birthday_set;
*swig_Headsize_get = *biosigc::HDRTYPE_Patient_Headsize_get;
*swig_Headsize_set = *biosigc::HDRTYPE_Patient_Headsize_set;
*swig_Sex_get = *biosigc::HDRTYPE_Patient_Sex_get;
*swig_Sex_set = *biosigc::HDRTYPE_Patient_Sex_set;
*swig_Handedness_get = *biosigc::HDRTYPE_Patient_Handedness_get;
*swig_Handedness_set = *biosigc::HDRTYPE_Patient_Handedness_set;
*swig_Smoking_get = *biosigc::HDRTYPE_Patient_Smoking_get;
*swig_Smoking_set = *biosigc::HDRTYPE_Patient_Smoking_set;
*swig_AlcoholAbuse_get = *biosigc::HDRTYPE_Patient_AlcoholAbuse_get;
*swig_AlcoholAbuse_set = *biosigc::HDRTYPE_Patient_AlcoholAbuse_set;
*swig_DrugAbuse_get = *biosigc::HDRTYPE_Patient_DrugAbuse_get;
*swig_DrugAbuse_set = *biosigc::HDRTYPE_Patient_DrugAbuse_set;
*swig_Medication_get = *biosigc::HDRTYPE_Patient_Medication_get;
*swig_Medication_set = *biosigc::HDRTYPE_Patient_Medication_set;
*swig_Impairment_get = *biosigc::HDRTYPE_Patient_Impairment_get;
*swig_Impairment_set = *biosigc::HDRTYPE_Patient_Impairment_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_Patient(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_Patient($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_Patient_Impairment ##############

package biosig::HDRTYPE_Patient_Impairment;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_Visual_get = *biosigc::HDRTYPE_Patient_Impairment_Visual_get;
*swig_Visual_set = *biosigc::HDRTYPE_Patient_Impairment_Visual_set;
*swig_Heart_get = *biosigc::HDRTYPE_Patient_Impairment_Heart_get;
*swig_Heart_set = *biosigc::HDRTYPE_Patient_Impairment_Heart_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_Patient_Impairment(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_Patient_Impairment($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : biosig::HDRTYPE_data ##############

package biosig::HDRTYPE_data;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( biosig );
%OWNER = ();
%ITERATORS = ();
*swig_size_get = *biosigc::HDRTYPE_data_size_get;
*swig_size_set = *biosigc::HDRTYPE_data_size_set;
*swig_block_get = *biosigc::HDRTYPE_data_block_get;
*swig_block_set = *biosigc::HDRTYPE_data_block_set;
sub new {
    my $pkg = shift;
    my $self = biosigc::new_HDRTYPE_data(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        biosigc::delete_HDRTYPE_data($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package biosig;

*noFile = *biosigc::noFile;
*unknown = *biosigc::unknown;
*ABF = *biosigc::ABF;
*ACQ = *biosigc::ACQ;
*ACR_NEMA = *biosigc::ACR_NEMA;
*AIFC = *biosigc::AIFC;
*AIFF = *biosigc::AIFF;
*AINF = *biosigc::AINF;
*alpha = *biosigc::alpha;
*AU = *biosigc::AU;
*ASF = *biosigc::ASF;
*ATES = *biosigc::ATES;
*ATF = *biosigc::ATF;
*AVI = *biosigc::AVI;
*BCI2000 = *biosigc::BCI2000;
*BDF = *biosigc::BDF;
*BIN = *biosigc::BIN;
*BKR = *biosigc::BKR;
*BLSC = *biosigc::BLSC;
*BMP = *biosigc::BMP;
*BNI = *biosigc::BNI;
*BSCS = *biosigc::BSCS;
*BrainVision = *biosigc::BrainVision;
*BrainVisionVAmp = *biosigc::BrainVisionVAmp;
*BrainVisionMarker = *biosigc::BrainVisionMarker;
*BZ2 = *biosigc::BZ2;
*CDF = *biosigc::CDF;
*CFWB = *biosigc::CFWB;
*CNT = *biosigc::CNT;
*CTF = *biosigc::CTF;
*DICOM = *biosigc::DICOM;
*DEMG = *biosigc::DEMG;
*EBS = *biosigc::EBS;
*EDF = *biosigc::EDF;
*EEG1100 = *biosigc::EEG1100;
*EEProbe = *biosigc::EEProbe;
*EEProbe2 = *biosigc::EEProbe2;
*EEProbeAvr = *biosigc::EEProbeAvr;
*EGI = *biosigc::EGI;
*EGIS = *biosigc::EGIS;
*ELF = *biosigc::ELF;
*EMBLA = *biosigc::EMBLA;
*ET_MEG = *biosigc::ET_MEG;
*ETG4000 = *biosigc::ETG4000;
*EVENT = *biosigc::EVENT;
*EXIF = *biosigc::EXIF;
*FAMOS = *biosigc::FAMOS;
*FEF = *biosigc::FEF;
*FITS = *biosigc::FITS;
*FLAC = *biosigc::FLAC;
*GDF = *biosigc::GDF;
*GDF1 = *biosigc::GDF1;
*GIF = *biosigc::GIF;
*GTF = *biosigc::GTF;
*GZIP = *biosigc::GZIP;
*HDF = *biosigc::HDF;
*HL7aECG = *biosigc::HL7aECG;
*JPEG = *biosigc::JPEG;
*Lexicor = *biosigc::Lexicor;
*Matlab = *biosigc::Matlab;
*MFER = *biosigc::MFER;
*MIDI = *biosigc::MIDI;
*MIT = *biosigc::MIT;
*MM = *biosigc::MM;
*MSI = *biosigc::MSI;
*native = *biosigc::native;
*NetCDF = *biosigc::NetCDF;
*NEX1 = *biosigc::NEX1;
*NIFTI = *biosigc::NIFTI;
*OGG = *biosigc::OGG;
*OpenXDF = *biosigc::OpenXDF;
*PBMA = *biosigc::PBMA;
*PBMN = *biosigc::PBMN;
*PDF = *biosigc::PDF;
*PDP = *biosigc::PDP;
*Persyst = *biosigc::Persyst;
*PGMA = *biosigc::PGMA;
*PGMB = *biosigc::PGMB;
*PLEXON = *biosigc::PLEXON;
*PNG = *biosigc::PNG;
*PNM = *biosigc::PNM;
*POLY5 = *biosigc::POLY5;
*PPMA = *biosigc::PPMA;
*PPMB = *biosigc::PPMB;
*PS = *biosigc::PS;
*RIFF = *biosigc::RIFF;
*SCP_ECG = *biosigc::SCP_ECG;
*SIGIF = *biosigc::SIGIF;
*Sigma = *biosigc::Sigma;
*SMA = *biosigc::SMA;
*SND = *biosigc::SND;
*SVG = *biosigc::SVG;
*SXI = *biosigc::SXI;
*TIFF = *biosigc::TIFF;
*TMS32 = *biosigc::TMS32;
*TMSiLOG = *biosigc::TMSiLOG;
*TRC = *biosigc::TRC;
*UNIPRO = *biosigc::UNIPRO;
*VRML = *biosigc::VRML;
*VTK = *biosigc::VTK;
*WAV = *biosigc::WAV;
*WinEEG = *biosigc::WinEEG;
*WMF = *biosigc::WMF;
*XML = *biosigc::XML;
*XPM = *biosigc::XPM;
*Z = *biosigc::Z;
*ZIP = *biosigc::ZIP;
*ZIP2 = *biosigc::ZIP2;
*ASCII_IBI = *biosigc::ASCII_IBI;
*ASCII = *biosigc::ASCII;
1;
